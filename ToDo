# general

- find a nice acronym for round
- interface between the algorithm and the predicate
- expected number of messages for a round: inferred from the send function
- locally testable safety/liveness conditions: of the form ∀ p. QF-φ(p)
- split the sources into multiple parts/sub-projects
  so we can use macros for the testing and debugging in the main project
  cleaner separation between the runtime and the declarations

# implementation

- uses netty 4.0.21 when on maven
- more predicates 
- ghost variables: make sure they are only read in the verification part and remove at compile time
- too much locking in the message reception and delivery
- memory leak when starting the first instance (message comes while instance starts ?)
- test with message drop
- test with more processes
- custom dispatch to avoid overwhelming the pipeline


# verification

- add temporal elements to spec/formula
- better structure of the specification: which invariant we can use to prove what property.
- extraction of transition relation:
    * constuctor and projection for tuples
    * in LockManager: confusion between Int and ProcessID (defined as alias ...)
    * purification should not be applied to boolean connective
    * purification is applied when the top level ∀ quantifiers are not there 
- decision procedure


# example

- find an application of LatticeAgreement
- implement multi-Paxos, equalitarian paxos


# network emulation: packet loss, delay, ...

- http://www.linuxfoundation.org/collaborate/workgroups/networking/netem
- https://gist.github.com/trongthanh/1196596
- http://www.cs.virginia.edu/~sdb7e/os_project/assignment.html

