# general

- find a nice acronym for 'round'
- interface between the algorithm and the predicate
- expected number of messages for a round: inferred from the send function
- locally testable safety/liveness conditions: of the form ∀ p. QF-φ(p)
- split the sources into multiple parts/sub-projects
  * cleaner separation between the runtime and the declarations
  * so we can use macros for the testing and debugging in the main project
  * Args and some utils as separate projects
- integrate recovery


# implementation

- uses netty 4.0.21 when on maven
  * check where the leak is (occurs only at the beginning, lazy init / race ?)
- ghost variables: make sure they are only read in the verification part and removed at compile time
- test with message drop (reliability)
- test with more processes (scalability)
- predicate: buffer message while one thread delivers
- change the (de)serialization:
    * our own stuff for primitive types, pickling for the rest
    * get rid of Message.scala (generate extraction primitives in process)
- report macro bug about accessing members of outer class inside an inner class

# verification

- add temporal elements to spec/formula
- better structure of the specification: which invariant we can use to prove what property.
- extraction of transition relation:
    * in LockManager: confusion between Int and ProcessID (defined as alias ...)
    * ...
- try type checking the formula
- decision procedure
- depolymorphize the formula in the SMT backend


# example

- find an application of LatticeAgreement
- implement multi-Paxos, equalitarian paxos
- specialize the OTR to avoid the "1st message → initial value"


# network emulation: packet loss, delay, ...

- http://www.linuxfoundation.org/collaborate/workgroups/networking/netem
- https://gist.github.com/trongthanh/1196596
- http://www.cs.virginia.edu/~sdb7e/os_project/assignment.html

