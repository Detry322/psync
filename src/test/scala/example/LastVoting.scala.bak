package example

import round._
import round.Time._
import round.formula._
import round.macros.Macros._

class LastVoting extends Algorithm[ConsensusIO] {

  import VarHelper._
  import SpecHelper._

  val V = new Domain[Int]

  //variables
  val x = new LocalVariable[Int](0)
  val ts = new LocalVariable[Time](-1)
  val ready = new LocalVariable[Boolean](false)
  val commit = new LocalVariable[Boolean](false)
  val vote = new LocalVariable[Int](0)
  val decision = new LocalVariable[Int](-1) //TODO as ghost
  val decided = new LocalVariable[Boolean](false)
  //
  val callback = new LocalVariable[ConsensusIO](null)


  //FIXME once the macro issue is sorted out ...
  //rotating coordinator
  def coord(phi: Int): ProcessID = new ProcessID((phi % n).toShort)

  val spec = new Spec {
      val livenessPredicate = List[Formula](
        P.exists( p => P.forall( q => p == coord(r/4) && HO(p).contains(q) && HO(p).size > n/2 ) )
      )

      val noDecision: Formula = P.forall( i => !decided(i) && !ready(i))

      val majority: Formula =
        V.exists( v => V.exists( t => {
            val A = P.filter( i => ts(i) >= t )
            A.size > n/2 &&
            t <= r/4 &&
            P.forall( i => (A.contains(i) ==> (x(i) == v) ) &&
                           (decided(i) ==> (decision(i) == v) ) &&
                           (commit(i) ==> (vote(i) == v) ) &&
                           (ready(i) ==> (vote(i) == v) ) &&
                           ((ts(i) == r/4) ==> commit(coord(r/4)) ))
        }) )

      val keepInit: Formula = P.forall( i => P.exists( j1 => x(i) == init(x)(j1) ))

      val safetyInv = And(keepInit, Or(noDecision, majority))

      val invariants = List[Formula](
        safetyInv,
        P.exists( j => P.forall( i => decided(i) && decision(i) == init(x)(j)) )
      )
      
      override val roundInvariants = List(
        List[Formula](
          true,
          P.exists( i => commit(i) )
        ),
        List[Formula](
          true,
          P.exists( i => commit(i) && P.forall( j => ts(j) == r/4 && x(j) == vote(i) ))
        ),
        List[Formula](
          true,
          P.exists( i => commit(i) && ready(i) && P.forall( j => ts(j) == r/4 && x(j) == vote(i) ))
        )
      )

      val properties = List[(String,Formula)](
        ("Termination",    P.forall( i => decided(i)) ),
        ("Agreement",      P.forall( i => P.forall( j => (decided(i) && decided(j)) ==> (decision(i) == decision(j)) ))),
        ("Validity",       P.forall( i => decided(i) ==> P.exists( j => init(x)(j) == decision(i) ))),
        ("Integrity",      P.exists( j => P.forall( i => decided(i) ==> (decision(i) == init(x)(j)) ))),
        ("Irrevocability", P.forall( i => old(decided)(i) ==> (decided(i) && old(decision)(i) == decision(i)) ))
      )
  }
  
  def process = p(new Process[ConsensusIO]{
      
    def init(io: ConsensusIO) {
      callback <~ io
      x <~ io.initialValue
      ts <~ -1
      decided <~ false 
      ready <~ false
      commit <~ false
    }

    val rounds = phase(
      new Round{

        type A = (Int, Int)

        def send(): Map[ProcessID,(Int, Time)] = {
          Map(coord(r / 4) -> (x: Int, ts: Time))
        }

        override def expectedNbrMessages = if (id == coord(r/4)) n/2 + 1 else 0

        def update(mailbox: Map[ProcessID,(Int, Time)]) {
          if (id == coord(r/4) && mailbox.size > n/2) {
            // let θ be one of the largest θ from 〈ν, θ〉received
            // vote(p) := one ν such that 〈ν, θ〉 is received
            vote <~ mailbox.maxBy(_._2._2)._2._1
            commit <~ true
          }
        }

      },

      new Round{

        type A = Int

        def send(): Map[ProcessID,Int] = {
          if (id == coord(r/4) && commit) {
            broadcast(vote)
          } else {
            Map.empty
          }
        }

        override def expectedNbrMessages = 1

        def update(mailbox: Map[ProcessID,Int]) {
          if (mailbox contains coord(r/4)) {
            x <~ mailbox(coord(r/4))
            ts <~ r/4
          }
        }

      },

      new Round{

        //place holder for ACK
        type A = Int

        def send(): Map[ProcessID,Int] = {
          if ( ts == (r/4) ) {
            Map( coord(r/4) -> (x: Int) )
          } else {
            Map.empty
          }
        }

        override def expectedNbrMessages = if (id == coord(r/4)) n/2 + 1 else 0

        def update(mailbox: Map[ProcessID,Int]) {
          if (id == coord(r/4) && mailbox.size > n/2) {
            ready <~ true
          }
        }

      },

      new Round{

        type A = Int

        def send(): Map[ProcessID,Int] = {
          if (id == coord(r/4) && ready) {
            broadcast(vote)
          } else {
            Map.empty
          }
        }

        override def expectedNbrMessages = 1 

        def update(mailbox: Map[ProcessID,Int]) {
          if (mailbox contains coord(r/4)) {
            val v = mailbox(coord(r/4))
            if (!decided) {
              callback.decide(v)
              decision <~ v
              decided <~ true
            }
          }
          ready <~ false
          commit <~ false
          if ((decided: Boolean)) {
            //terminate()
            exitAtEndOfRound()
          }
        }

      }

    )

  })

}
