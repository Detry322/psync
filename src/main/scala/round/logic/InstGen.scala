package round.logic

import round.formula._

import dzufferey.utils.Logger
import dzufferey.utils.LogLevel._
import dzufferey.utils.Namer

//Would it be better to instantiate the universal on the ground terms and then apply the procedure ?
//Some base for local theories and other such things  
//we need:
// * e-matching
// * congurence closure, equivalence classes
// * term generator (for ψ-locality)
// * flattening of axioms (introduce some ⇒)
// * set of ground terms
// * namer for hygiene

//TODO
// more efficient implementation
// better simplification:
//  redundant terms and formula being generated multiple times

/** Instance generation: methods to instanciate the quantifiers */
object InstGen {

  /** instantiate the given free variable with the provided gounded terms (substitution) */
  protected def instantiateWithTerms(v: Variable, axiom: Formula, groundTerms: Set[Formula]): List[Formula] = {
    if (!axiom.freeVariables.contains(v)) List(axiom)
    else {
      val candidates = groundTerms.filter(_.tpe == v.tpe).toList
      Logger("InstGen", Debug, "(O) instantiating "+ v +" with " + candidates.mkString(", "))
      candidates.toList.map( gt => FormulaUtils.replace(v, gt, axiom) )
    }
  }

  //the returned formula still contains ∃ quantifiers
  protected def instantiateGlobally(formula: Formula, groundTerms: Set[Formula]): Formula =
    instantiateGlobally(formula, Set(), true, groundTerms)

  //TODO that can get very slow
  //find a better way to handle Opt vs Mandatory branching (now is 2^#vars)
  //this should cache the path with the global instantiation
  /* the returned formula still contains ∃ quantifiers
   * if (didMandatory) assume mandatoryTerms ⊆ groundTerms
   */
  protected def instantiateGlobally(formula: Formula,
                                    mandatoryTerms: Set[Formula],
                                    didMandatory: Boolean,
                                    groundTerms: Set[Formula]): Formula = {
    var cacheAll = scala.collection.mutable.HashMap[(Variable,Formula),List[Formula]]()
    var cacheGnd = scala.collection.mutable.HashMap[(Variable,Formula),List[Formula]]()
    var allTerms = mandatoryTerms ++ groundTerms
    def instCache(cache: scala.collection.mutable.HashMap[(Variable,Formula),List[Formula]],
                  v: Variable, f: Formula, ts: Set[Formula]): List[Formula] = {
      if (cache.contains(v -> f)) {
        cache(v -> f)
      } else {
        val f2 = instantiateWithTerms(v, f, ts)
        cache += ((v -> f) -> f2)
        f2
      }
    }
    def instAll(v: Variable, f: Formula): List[Formula] = instCache(cacheAll, v, f, allTerms)
    def instGnd(v: Variable, f: Formula): List[Formula] = instCache(cacheGnd, v, f, groundTerms)
    def process(formula: Formula, didMandatory: Boolean): Formula = formula match {
      case Not(arg) =>
        Not(process(arg, didMandatory))
      case Or(args @ _*) =>
        val args2 = args.map(process(_, didMandatory))
        Or(args2:_*)
      case And(args @ _*) =>
        val args2 = args.map(process(_, didMandatory))
        val args3 = args2.flatMap(FormulaUtils.getConjuncts)
        And(args3:_*)
      case Exists(vs, f) =>
        Exists(vs, process(f, didMandatory))
      case ForAll(v :: vs, f) =>
        val f2 = if (allTerms.forall(_.tpe != v.tpe)) True()
                 else process(ForAll(vs, f), didMandatory)
        if (didMandatory) {
          val f3 = instAll(v, f2)
          And(f3:_*)
        } else {
          //case 1: do the mandatory thing
          val candidates = mandatoryTerms.filter(_.tpe == v.tpe).toList
          val f2Now = if (candidates.isEmpty) True()
                      else process(ForAll(vs, f), true)
          Logger("InstGen", Debug, "(M) instantiating "+ v +" with " + candidates.mkString(", "))
          val f3Now = candidates.toList.map( gt => FormulaUtils.replace(v, gt, f2Now) )
          //case 2: do some non-mandatoryTerms
          val f3 = instGnd(v, f2)
          And((f3Now ++ f3):_*)
        }
      case ForAll(Nil, f) =>
        if (!didMandatory && FormulaUtils.universallyBound(f).isEmpty) True()
        else process(f, didMandatory)
      case other => other
    }
    process(formula, didMandatory)
  }
  
  //Get terms generated by the universally quantified variables
  //-uVars: set of universally quantified variables
  protected def termsGeneratedBy( uVars: Set[Variable],
                                  f: Formula): Set[Formula] = {
    assert(f.tpe == Bool, "termsGeneratedBy needs to be called at the boolean level")
    def ok(f: Formula) = {
      f.tpe != Bool && f.boundVariables.isEmpty &&
      f.freeVariables.exists( v => uVars(v) )
    }
    def collect(acc: Set[Formula], f: Formula): Set[Formula] = {
      if (f.tpe == Bool)
        f match {
          case Binding(_,_,f) => if (ok(f)) acc + f else acc
          case Application(_, args) => acc ++ args.filter(ok)
          case _ => acc
        }
      else acc
    }
    FormulaUtils.collect(Set[Formula](), collect, f)
  }

  protected def instantiateLocally( formula: Formula,
                                    mandatoryTerms: Set[Formula],
                                    groundTerms: Set[Formula],
                                    cClasses: CongruenceClasses): Formula = {
    assert(groundTerms subsetOf cClasses.groundTerms)
    val m = new Matching(cClasses)
    def processClause(f: Formula): Formula = {
      val (f2, _uvars) = Quantifiers.getUniversalPrefix(f)
      val uvars = _uvars.toSet
      val generatingTerms = termsGeneratedBy(uvars, f2)
      val init = Set(Map[Variable,Formula]())
      val candidates = generatingTerms.foldLeft(init)( (acc, gen) => {
        Matching.mergeMaps(acc, m.find(gen, uvars))
      })
      val insts = candidates.toList.flatMap( m => {
        assert(uvars.forall( v => m contains v ), "not value for all the variables")
        def map(f: Formula): Formula = f match {
          case v @ Variable(_) => m.getOrElse(v, v)
          case other => other
        }
        val f = FormulaUtils.map(map, f2)
        if (FormulaUtils.exists(mandatoryTerms, f)) Some(f)
        else None
      })
      And(insts:_*)
    }
    val clauses = FormulaUtils.getConjuncts(formula)
    And(clauses.map(processClause):_*)
  }

  //TODO a local up to CC version of the instantiation

  def postprocess(f: Formula): Formula = {
    val simp = Simplify.boundVarUnique(f)
    val qf = Quantifiers.skolemize(simp)
    Simplify.simplifyBool(FormulaUtils.flatten(qf))
  }

  //at least one variable must be instantiated with one of the new term
  protected def instanciateOneStep( formula: Formula,
                                    mandatoryTerms: Set[Formula],
                                    gts: Set[Formula],
                                    cClasses: CongruenceClasses,
                                    local: Boolean ): Formula = {
    if (local) {
      instantiateLocally(formula, mandatoryTerms, gts, cClasses)
    } else {
      val mRepr = mandatoryTerms.map(cClasses.repr(_))
      val gRepr = gts.map(cClasses.repr(_)) -- mRepr
      instantiateGlobally(formula, mRepr, false, gRepr)
      //TODO this adds some new terms, we should instantiateLocally on those terms
    }
  }


  protected def generatedTerms( formula: Formula,
                                cClasses: CongruenceClasses,
                                depth: Option[Int] ): Formula = {
    val clauses = FormulaUtils.getConjuncts(formula)
    val genTerms: List[(List[Variable],Formula)] = clauses.flatMap( f => {
      val (f2, _uvars) = Quantifiers.getUniversalPrefix(f)
      val uvars = _uvars.toSet
      val gens = termsGeneratedBy(uvars, f2)
      gens.toList.map(g => {
        val needed = uvars.intersect(g.freeVariables).toList
        Simplify.deBruijnIndex(ForAll(needed, g)) match {
          case ForAll(vs, f) => vs -> f
          case other => Logger.logAndThrow("InstGen", Error, "expect ∀, found: " + other)
        }
      })
    })
    //TODO create a map from type to index by type of vars so we can easily generate
    //TODO when there are multiple vars once one is instantiated we should add the ...
    ???
  }
  
  /** instantiate all the universally quantified variables with the provided ground terms.
   * @param formula list of formula
   * @param mandatoryTerms given an chain of quantified variables, at least one of them will be instantiated with a mandatory term. The others may also use the optionalTerms
   * @param optionalTerms (optional) set of terms to add to the terms present in the formulas
   * @param cClasses (optional) congruence classes to reduce the number of terms used in the instantiation
   * @param depth (optional) bound on the recursion depth (depth 0 does not intruduce new ground terms)
   * @param local (optional) should the instantiation be local (default is false)
   */
  def saturateWith( formula: Formula,
                    mandatoryTerms: Set[Formula],
                    optionalTerms: Set[Formula] = Set(),
                    cClasses: CongruenceClasses = CongruenceClasses.empty,
                    depth: Option[Int] = None,
                    local: Boolean = false ): Formula = {
    //TODO smarter strategy:
    //for depth rounds, generate new terms, then do one step of local instantiation
    val gts = mandatoryTerms ++ optionalTerms ++ FormulaUtils.collectGroundTerms(formula)
    //ground terms are from the epr part 
    val formula2 = instanciateOneStep(formula, mandatoryTerms, gts, cClasses, local)
    if (depth.getOrElse(1) <= 0) {
      if (!local) {
        val gts2 = FormulaUtils.collectGroundTerms(formula2) -- gts
        val cClasses1 = CongruenceClosure(And(formula2, cClasses.formula))
        val formula3 = instanciateOneStep(formula, gts2, cClasses1.groundTerms, cClasses1, true)
        val formula4 = And(formula2, formula3)
        postprocess(formula4)
      } else {
        postprocess(formula2)
      }
    } else {
      val gts2 = FormulaUtils.collectGroundTerms(formula2) -- gts
      if (gts2.isEmpty) {
        postprocess(formula2)
      } else {
        val cClasses1 = CongruenceClosure(And(formula2, cClasses.formula))
        saturateWith(formula, gts2, gts, cClasses1, depth.map(_ - 1), local)
      }
    }
  }

  /** instantiate all the universally quantified variables with the provided ground terms.
   * @param formula list of formula
   * @param groundTerms (optional) set of terms to add to the terms present in the formulas
   * @param cClasses (optional) congruence classes to reduce the number of terms used in the instantiation
   * @param depth (optional) bound on the recursion depth (depth 0 does not intruduce new ground terms)
   * @param local (optional) should the instantiation be local (default is false)
   */
  def saturate( formula: Formula,
                groundTerms: Set[Formula] = Set(),
                cClasses: CongruenceClasses = CongruenceClasses.empty,
                depth: Option[Int] = None,
                local: Boolean = false ): Formula = {
    val gts = groundTerms ++ FormulaUtils.collectGroundTerms(formula)
    saturateWith(formula, gts, Set(), cClasses, depth, local)
  }
 
}
