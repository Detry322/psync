package round.logic

import round.formula._

import dzufferey.utils.Logger
import dzufferey.utils.LogLevel._
import dzufferey.utils.Namer

//Would it be better to instantiate the universal on the ground terms and then apply the procedure ?
//Some base for local theories and other such things  
//we need:
// * e-matching
// * congurence closure, equivalence classes
// * term generator (for ψ-locality)
// * flattening of axioms (introduce some ⇒)
// * set of ground terms
// * namer for hygiene

//TODO
// more efficient implementation
// better simplification:
//  redundant terms and formula being generated multiple times

/** Instance generation: methods to instanciate the quantifiers */
object InstGen {

  /** instantiate the given free variable with the provided gounded terms (substitution) */
  protected def instantiateWithTerms(v: Variable, axiom: Formula, groundTerms: Set[Formula]): List[Formula] = {
    if (!axiom.freeVariables.contains(v)) List(axiom)
    else {
      val candidates = groundTerms.filter(_.tpe == v.tpe).toList
      Logger("InstGen", Debug, "(O) instantiating "+ v +" with " + candidates.mkString(", "))
      candidates.toList.map( gt => FormulaUtils.replace(v, gt, axiom) )
    }
  }

  //Get terms generated by the universally quantified variables
  //-uVars: set of universally quantified variables
  protected def termsGeneratedBy( uVars: Set[Variable],
                                  f: Formula): Set[Formula] = {
    assert(f.tpe == Bool, "termsGeneratedBy needs to be called at the boolean level")
    def ok(f: Formula) = {
      f.tpe != Bool && f.boundVariables.isEmpty &&
      f.freeVariables.exists( v => uVars(v) )
    }
    def collect(acc: Set[Formula], f: Formula): Set[Formula] = {
      if (f.tpe == Bool)
        f match {
          case Binding(_,_,f) => if (ok(f)) acc + f else acc
          case Application(_, args) => acc ++ args.filter(ok)
          case _ => acc
        }
      else acc
    }
    FormulaUtils.collect(Set[Formula](), collect, f)
  }

  protected def instantiateLocally( formula: Formula,
                                    mandatoryTerms: Set[Formula],
                                    groundTerms: Set[Formula],
                                    cClasses: CongruenceClasses): Formula = {
    assert(groundTerms subsetOf cClasses.groundTerms)
    val m = new Matching(cClasses)
    def processClause(f: Formula): Formula = {
      val (f2, _uvars) = Quantifiers.getUniversalPrefix(f)
      val uvars = _uvars.toSet
      val generatingTerms = termsGeneratedBy(uvars, f2)
      val init = Set(Map[Variable,Formula]())
      val candidates = generatingTerms.foldLeft(init)( (acc, gen) => {
        Matching.mergeMaps(acc, m.find(gen, uvars))
      })
      val insts = candidates.toList.flatMap( m => {
        assert(uvars.forall( v => m contains v ), "not value for all the variables")
        def map(f: Formula): Formula = f match {
          case v @ Variable(_) => m.getOrElse(v, v)
          case other => other
        }
        val f = FormulaUtils.map(map, f2)
        if (FormulaUtils.exists(mandatoryTerms, f)) Some(f)
        else None
      })
      And(insts:_*)
    }
    val clauses = FormulaUtils.getConjuncts(formula)
    And(clauses.map(processClause):_*)
  }

  //TODO a local up to CC version of the instantiation

  def postprocess(f: Formula): Formula = {
    val simp = Simplify.boundVarUnique(f)
    val qf = Quantifiers.skolemize(simp)
    Simplify.simplifyBool(FormulaUtils.flatten(qf))
  }

  //at least one variable must be instantiated with one of the new term
  protected def instanciateOneStep( formula: Formula,
                                    mandatoryTerms: Set[Formula],
                                    gts: Set[Formula],
                                    cClasses: CongruenceClasses,
                                    local: Boolean ): Formula = {
    if (local) {
      instantiateLocally(formula, mandatoryTerms, gts, cClasses)
    } else {
      val cc = new CongruenceClosure //TODO reuse
      cc(cClasses.formula)
      val mRepr = mandatoryTerms.map(cClasses.repr(_))
      val gRepr = gts.map(cClasses.repr(_)) -- mRepr
      val gen = new IncrementalInstanceGenerator(formula, cc)
      gen.generate(gRepr) //ignore the ones from the existing terms
      And(gen.generate(mRepr) :_*)
    }
  }
  
  /** instantiate all the universally quantified variables with the provided ground terms.
   TODO get rid of this and replace by something simpler (also use CongruenceClosure instead of CongruenceClasses)
   * @param formula list of formula
   * @param mandatoryTerms given an chain of quantified variables, at least one of them will be instantiated with a mandatory term. The others may also use the optionalTerms
   * @param optionalTerms (optional) set of terms to add to the terms present in the formulas
   * @param cClasses (optional) congruence classes to reduce the number of terms used in the instantiation
   TODO simplify that: depth 0 should be local, anything above that generates terms
   * @param depth (optional) bound on the recursion depth
   * @param local (optional) should the instantiation be local (default is false)
   */
  def saturateWith( formula: Formula,
                    mandatoryTerms: Set[Formula],
                    optionalTerms: Set[Formula] = Set(),
                    cClasses: CongruenceClasses = CongruenceClasses.empty,
                    depth: Option[Int] = None,
                    local: Boolean = false ): Formula = {
    //TODO smarter strategy:
    //for depth rounds, generate new terms, then do one step of local instantiation
    val gts = mandatoryTerms ++ optionalTerms ++ FormulaUtils.collectGroundTerms(formula)
    //ground terms are from the epr part 
    val formula2 = instanciateOneStep(formula, mandatoryTerms, gts, cClasses, local)
    if (depth.getOrElse(1) <= 0) {
      if (!local) {
        val gts2 = FormulaUtils.collectGroundTerms(formula2) -- gts
        val cClasses1 = CongruenceClosure(And(formula2, cClasses.formula))
        val formula3 = instanciateOneStep(formula, gts2, cClasses1.groundTerms, cClasses1, true)
        val formula4 = And(formula2, formula3)
        postprocess(formula4)
      } else {
        postprocess(formula2)
      }
    } else {
      val gts2 = FormulaUtils.collectGroundTerms(formula2) -- gts
      if (gts2.isEmpty) {
        postprocess(formula2)
      } else {
        val cClasses1 = CongruenceClosure(And(formula2, cClasses.formula))
        saturateWith(formula, gts2, gts, cClasses1, depth.map(_ - 1), local)
      }
    }
  }

  /** instantiate all the universally quantified variables with the provided ground terms.
   * @param formula list of formula
   * @param groundTerms (optional) set of terms to add to the terms present in the formulas
   * @param cClasses (optional) congruence classes to reduce the number of terms used in the instantiation
   TODO simplify that: depth 0 should be local, anything above that generates terms
   * @param depth (optional) bound on the recursion depth
   * @param local (optional) should the instantiation be local (default is false)
   */
  def saturate( formula: Formula,
                groundTerms: Set[Formula] = Set(),
                cClasses: CongruenceClasses = CongruenceClasses.empty,
                depth: Option[Int] = None,
                local: Boolean = false ): Formula = {
    if (local) {
      val gts = groundTerms ++ FormulaUtils.collectGroundTerms(formula)
      saturateWith(formula, gts, Set(), cClasses, depth, local)
    } else {
      val cc = new CongruenceClosure //TODO reuse
      cc(cClasses.formula)
      saturate1(formula, depth, groundTerms, cc)
    }
  }

  def saturate1(formula: Formula,
                depth: Option[Int] = None,
                groundTerms: Set[Formula] = Set(),
                cc: CongruenceClosure = new CongruenceClosure): Formula = {
    groundTerms.foreach(cc.repr) //make sure all the terms are in cc
    cc(formula)
    val (ax, rest) = FormulaUtils.getConjuncts(formula).partition(Quantifiers.hasFAnotInComp)
    val gen = new IncrementalInstanceGenerator(And(ax:_*), cc)
    val insts = gen.saturate(depth)
    And(rest ++ insts :_*)
  }
 
}
