package round.logic

import round.formula._

import dzufferey.utils.Logger
import dzufferey.utils.LogLevel._
import dzufferey.utils.Namer

//Would it be better to instantiate the universal on the ground terms and then apply the procedure ?
//Some base for local theories and other such things  
//we need:
// * e-matching
// * congurence closure, equivalence classes
// * term generator (for ψ-locality)
// * flattening of axioms (introduce some ⇒)
// * set of ground terms
// * namer for hygiene

//TODO
// more efficient implementation
// better simplification:
//  redundant terms and formula being generated multiple times

/** Instance generation: methods to instanciate the quantifiers */
object InstGen {

  /** instantiate the given free variable with the provided gounded terms (substitution) */
  protected def instantiateWithTerms(v: Variable, axiom: Formula, groundTerms: Set[Formula]): List[Formula] = {
    if (!axiom.freeVariables.contains(v)) List(axiom)
    else {
      val candidates = groundTerms.filter(_.tpe == v.tpe).toList
      Logger("InstGen", Debug, "(O) instantiating "+ v +" with " + candidates.mkString(", "))
      candidates.toList.map( gt => FormulaUtils.replace(v, gt, axiom) )
    }
  }

  //Get terms generated by the universally quantified variables
  //-uVars: set of universally quantified variables
  protected def termsGeneratedBy( uVars: Set[Variable],
                                  f: Formula): Set[Formula] = {
    assert(f.tpe == Bool, "termsGeneratedBy needs to be called at the boolean level")
    def ok(f: Formula) = {
      f.tpe != Bool && f.boundVariables.isEmpty &&
      f.freeVariables.exists( v => uVars(v) )
    }
    def collect(acc: Set[Formula], f: Formula): Set[Formula] = {
      if (f.tpe == Bool)
        f match {
          case Binding(_,_,f) => if (ok(f)) acc + f else acc
          case Application(_, args) => acc ++ args.filter(ok)
          case _ => acc
        }
      else acc
    }
    FormulaUtils.collect(Set[Formula](), collect, f)
  }

  protected def instantiateLocally( formula: Formula,
                                    mandatoryTerms: Set[Formula],
                                    cClasses: CC): Formula = {
    def processClause(f: Formula): Formula = {
      val (f2, _uvars) = Quantifiers.getUniversalPrefix(f)
      val uvars = _uvars.toSet
      val generatingTerms = termsGeneratedBy(uvars, f2)
      val init = Set(Map[Variable,Formula]())
      val candidates = generatingTerms.foldLeft(init)( (acc, gen) => {
        Matching.mergeMaps(acc, Matching.find(cClasses, uvars, gen))
      })
      val insts = candidates.toList.flatMap( m => {
        assert(uvars.forall( v => m contains v ), "not value for all the variables")
        def map(f: Formula): Formula = f match {
          case v @ Variable(_) => m.getOrElse(v, v)
          case other => other
        }
        val f = FormulaUtils.map(map, f2)
        if (FormulaUtils.exists(mandatoryTerms, f)) Some(f)
        else None
      })
      And(insts:_*)
    }
    val clauses = FormulaUtils.getConjuncts(formula)
    And(clauses.map(processClause):_*)
  }

  //TODO a local up to CC version of the instantiation

  def postprocess(f: Formula): Formula = {
    val simp = Simplify.boundVarUnique(f)
    val qf = Quantifiers.skolemize(simp)
    Simplify.simplifyBool(FormulaUtils.flatten(qf))
  }

  protected def toCongruenceClosure(cClasses: CC) = cClasses match {
    case c: CongruenceClosure => c
    case cl: CongruenceClasses =>
      val c = new CongruenceClosure
      c.addConstraints(cl.formula)
      c
    case other => sys.error("unexpected: " + other)
  }
  
  /** instantiate all the universally quantified variables with the provided ground terms.
   TODO get rid of this and replace by something simpler (also use CongruenceClosure instead of CongruenceClasses)
   * @param formula list of formula
   * @param mandatoryTerms given an chain of quantified variables, at least one of them will be instantiated with a mandatory term (or its representative in cClasses). The others may also use the optionalTerms.
   * @param optionalTerms (optional) set of terms to add to the terms present in the formulas
   * @param cClasses (optional) congruence classes to reduce the number of terms used in the instantiation
   TODO simplify that: depth 0 should be local, anything above that generates terms
   * @param depth (optional) bound on the recursion depth
   * @param local (optional) should the instantiation be local (default is false)
   */
  def saturateWith( formula: Formula,
                    mandatoryTerms: Set[Formula],
                    optionalTerms: Set[Formula] = Set(),
                    cClasses: CC = CongruenceClasses.empty,
                    depth: Option[Int] = None,
                    local: Boolean = false ): Formula = {
    //get an incremental CC
    val cc = toCongruenceClosure(cClasses)
    //push all the terms to be sure
    mandatoryTerms.foreach(cc.repr)
    optionalTerms.foreach(cc.repr)
    FormulaUtils.collectGroundTerms(formula).foreach(cc.repr)
    //make sure formula is taking into account
    cc.addConstraints(formula)

    if (local) {
      assert(depth.getOrElse(0) <= 0, "local and depth > 0 (" + depth + ")")
      val gts = cc.groundTerms
      //TODO do we need the double inst ?
      val formula2 = instantiateLocally(formula, mandatoryTerms, cc)
      val gts2 = FormulaUtils.collectGroundTerms(formula2) -- gts
      val formula3 = instantiateLocally(formula, gts2, cc)
      val formula4 = And(formula2, formula3)
      postprocess(formula4)
    } else {
      val (ax, rest) = FormulaUtils.getConjuncts(formula).partition(Quantifiers.hasFAnotInComp)
      val gen = new IncrementalGenerator(And(ax:_*), cc)
      val mRepr = mandatoryTerms.map(cc.repr)
      //ignore things without mandatoryTerms
      cc.groundTerms.view.map(cc.repr).filterNot(mRepr).foreach(gen.generate)
      //saturate with the remaining terms
      val insts = gen.saturate(depth)
      val res = And(rest ++ insts :_*)
      postprocess(res)
    }
  }

  /** instantiate all the universally quantified variables with the provided ground terms.
   * @param formula list of formula
   * @param groundTerms (optional) set of terms to add to the terms present in the formulas
   * @param cClasses (optional) congruence classes to reduce the number of terms used in the instantiation
   TODO simplify that: depth 0 should be local, anything above that generates terms
   * @param depth (optional) bound on the recursion depth
   * @param local (optional) should the instantiation be local (default is false)
   */
  def saturate( formula: Formula,
                groundTerms: Set[Formula] = Set(),
                cClasses: CC = CongruenceClasses.empty,
                depth: Option[Int] = None,
                local: Boolean = false ): Formula = {
    if (local) {
      val gts = groundTerms ++ FormulaUtils.collectGroundTerms(formula)
      saturateWith(formula, gts, Set(), cClasses, depth, local)
    } else {
      val cc = toCongruenceClosure(cClasses)
      saturate1(formula, depth, groundTerms, cc)
    }
  }

  def saturate1(formula: Formula,
                depth: Option[Int] = None,
                groundTerms: Set[Formula] = Set(),
                cc: CongruenceClosure = new CongruenceClosure): Formula = {
    groundTerms.foreach(cc.repr) //make sure all the terms are in cc
    cc.addConstraints(formula)
    val (ax, rest) = FormulaUtils.getConjuncts(formula).partition(Quantifiers.hasFAnotInComp)
    val gen = new IncrementalGenerator(And(ax:_*), cc)
    val insts = gen.saturate(depth)
    And(rest ++ insts :_*)
  }
 
}
