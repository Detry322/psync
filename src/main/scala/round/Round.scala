package round

import java.nio.ByteBuffer
import runtime.Message

import scala.pickling._
import binary._

//TODO not so nice (exn for control flow) but it will do for the moment
class TerminateInstance extends Exception() { }


abstract class Round {

  type A

  def send(): Set[(A, ProcessID)]

  def update(mailbox: Set[(A, ProcessID)]): Unit

  protected final def broadcast(msg: A): Set[(A, ProcessID)] = {
    group.replicas.foldLeft(Set.empty[(A,ProcessID)])( (acc, r) => acc + (msg -> r.id))
  }
  
  //to finish the instance
  protected final def terminate(): Nothing = {
    throw new TerminateInstance
  }

  //TODO
  def expectedNbrMessages: Int = group.size

  //////////////////
  // util methods //
  //////////////////

  //TODO a better way to hide/abstract the group
  private var group: round.runtime.Group = null
  def setGroup(g: round.runtime.Group) { group = g }

  //TODO because of bug in macros (should be in Process)
  var id = new ProcessID(0)

  //serialization is generated by macros

  protected def serialize(payload: A, out: ByteBuffer): Unit

  protected def deserialize(in: ByteBuffer): A

  final def packSend(buffers: Iterable[ByteBuffer]): Iterable[(ProcessID, ByteBuffer)] = {
    val msgs = send.iterator
    //println("sending: " + msgs.mkString(", "))
    val bufs = buffers.iterator
    var acc: List[(ProcessID, ByteBuffer)] = Nil
    while (msgs.hasNext) {
      val (value, dst) = msgs.next
      val buf = bufs.next
      buf.putLong(0l)
      serialize(value, buf)
      acc = (dst, buf) :: acc
    }
    acc
  }

  final def unpackUpdate(msg: Iterable[Message]) = {
    def decode(m: Message): (A, ProcessID) = {
      val pid = m.senderId
      val buf = m.payload
      buf.getLong()
      val a = deserialize(buf)
      m.release
      (a, pid)
    }
    val decoded = msg.map(decode).toSet
    update(decoded)
  }


  //////////////////////
  // for verification //
  //////////////////////

  import verification._

  //macros will take care of populating those fields
  val auxSpec: Map[String, AuxiliaryMethod] 
  val rawTR: RoundTransitionRelation
  val sendStr: String
  val updtStr: String

}



